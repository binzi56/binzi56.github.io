<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS Google地图开发小结(2017)]]></title>
    <url>%2F2017%2F09%2F26%2FiOS-GoogleMap%2F</url>
    <content type="text"><![CDATA[最近接触了一个international的项目, 用到Google地图, 在此稍微总结一下, 方便以后使用; 一. 准备工作开发Google地图当然离不开翻墙了, 先分享几个好用的免费翻墙软件: 1.软件:lantern(For Window, Mac, Android, Ubuntu) LetsVPN(appStore直接下载)(For iOS) 2.相关资料:Google地图API官方Google地图API SMCalloutView这个是点击大头针弹出信息框的自定义视图, 官方地图自定义有局限性, 下面👇会讲到, 示例如图: 二.开发内容对于iOS开发者, Google地图提供了两个开发入口:Maps SDK for iOS添加 Google 地图 Places API for iOS添加位置的最新信息 1.Places API for iOS这个一般开发Google地图用不到, 不过还是简单说一下, 官方demo截图; section0: (Autocomplete)Autocomplete主要功能是搜索相关的位置信息(文本方式);里面还会展示UISearchBar/UISearchViewController的几种呈现方法, 感兴趣的可以看看; section1: (Programmatic APIs) Programmatic APIs主要展示搜索或所选点附近的信息(地图方式); 2.Maps SDK for iOS重点介绍内容, mark, mark….还是一样, 先看下官方demo, 大概浏览一下Google地图的功能;123456//基本组成部分Map(地图): 基本的地图创建, 组件, 类别等;Panorama(全景): 固定/可旋转的街景;Overlays(覆盖物): 地图视图的自定义(地图大头针, 弹出信息框等);Camera(摄像头): 当前地图的可视范围(设置摄像头中心点坐标、镜头缩放比例、方向、视角等);Services(服务): 地理编码/逆地理编码; 2.1 常用类介绍:1234567GMSMapView 最主要的地图类GMSCameraPosition 地图摄像头，可以理解为当前地图的可视范围，可以获取到摄像头中心点坐标、镜头缩放比例、方向、视角等参数GMSMarker 地图大头针GMSGeocoder 反向地理编码类GMSAddress 反向地理编码返回的类,包含坐标及地理位置描述等信息CLLocationManager 就是CoreLocation框架下的地理位置管理类GMSAutocompleteFetcher 搜索自动补全抓取器，通过该类的代理方法实现搜索自动补全 2.2 常用方法介绍:GMSMapViewDelegate:12345678910mapView:willMove: 镜头即将移动时调用mapView:didChangeCameraPosition:镜头移动完成后调用mapView:didTapAtCoordinate: 点击地图时调用mapView:didLongPressAtCoordinate: 长按地图时调用mapView:didTapMarker: 点击大头针时调用mapView:didTapInfoWindowOfMarker: 点击大头针的弹出视窗时调用mapView:didLongPressInfoWindowOfMarker: 长按大头针视窗时调用mapView:markerInfoWindow: 自定义大头针弹出视窗，返回UIViewmapView:didCloseInfoWindowOfMarker: 自定义大头针弹出视窗关闭时调用mapView:didDragMarker: 拖拽大头针时调用didTapMyLocationButtonForMapView: 点击定位大头针, 返回BOOL值 2.3 Google Maps URL 架构(单独介绍一下):确实与国内不同, Google地图URL架构没在demo中介绍; 👇介绍一下: iOS 版 Google Maps 应用支持以下 URL 架构: comgooglemaps://和 comgooglemaps-x-callback://– 这些架构允许您启动 iOS 版 Google Maps 应用，并执行下列几项操作之一： 以指定的缩放级别显示指定位置的地图。 搜索位置或地点，并将它们显示在地图上。 请求从一个位置前往另一个位置的路线。 可以返回以下四种交通方式的路线：驾车、步行、骑自行车和乘坐公共交通工具。 向应用添加导航。 当应用完成后，使用 comgooglemaps-x-callback:// 发出一个回调。 回调经常用来使用户返回到最初打开 iOS 版 Google Maps 的应用。 comgooglemapsurl:// – 此架构允许您使用从桌面 Google Maps 网站得到的 URL 启动 iOS 版 Google Maps 应用。 这意味着您可以为用户提供原生移动体验，而不是简单地加载 Google Maps 网站。 原始 URL 可以是 maps.google.com，或者 google.com/maps，也可以使用任何有效的国家代码顶级域名来代替 com。 您还可以传递 goo.gl/maps 重定向 URL。您可以将 x-source 和 x-success 参数与 comgooglemapsurl:// URL 架构结合使用来发出回调。 2.3.1 检查设备上是否已安装 Google Maps 应用;123456if ([[UIApplication sharedApplication] canOpenURL: [NSURL URLWithString:@&quot;comgooglemaps://&quot;]]) &#123; //已安装Google地图APP&#125; else &#123; //未安装Google地图APP&#125; 2.3.2 显示地图参数: center：这是地图视口中心点。 其格式为用逗号分隔的字符串 latitude,longitude。 mapmode：设置所显示地图的种类。 可以设置为：standard 或 streetview。 如果未指定，则将使用当前的应用设置。 views：开启/关闭特定视图。 可以设置为：satellite、traffic 或 transit。 可以使用逗号分隔符来设置多个值。 如果指定了不带任何值的参数，那么将清除所有的视图。 zoom：指定地图的缩放级别。12//示例 URL，它以纽约为中心、采用 14 级缩放级别来显示地图，且开启了交通视图comgooglemaps://?center=40.765819,-73.975866&amp;zoom=14&amp;views=traffic 2.3.3 搜索参数: q：用于搜索的查询字符串。12//示例 URL 用来在指定位置附近搜索“Pizza&quot;comgooglemaps://?q=Pizza&amp;center=37.759748,-122.427135 2.3.4 显示路线参数: saddr：设置路线搜索的起点。 它可以是一个纬度、经度或查询格式的地址。 如果它是返回多个结果的查询字符串， 将选择第一个结果。 如果该值留空，那么将使用该用户的当前位置。 daddr：设置路线搜索的终点。 具有与 saddr 相同的格式和行为。 directionsmode：交通方式。 可以设置为：driving、transit、bicycling 或 walking。12// 示例 URL 用来显示 Google 纽约办事处与肯尼迪国际机场之间的交通路线comgooglemaps://?saddr=Google+Inc,+8th+Avenue,+New+York,+NY&amp;daddr=John+F.+Kennedy+International+Airport,+Van+Wyck+Expressway,+Jamaica,+New+York&amp;directionsmode=transit 2.3.5 指定回调URL参数: x-source – 发送 x-callback 请求的应用的名称。 最好使用短名称。 x-success – 完成时调用的 URL。 通常，这是您自己的应用的 URL 架构，可以让用户返回到原来的应用。1234// 示例将启动 iOS 版 Google Maps 应用，并以纽约为中心显示地图。 该应用还会显示标有“SourceApp”的按钮。 当点击“SourceApp”按钮时，iOS 版 Google Maps 应用将发出一个指向虚拟的 URL 架构的回调， sourceapp://?resume=true.comgooglemaps-x-callback://?center=40.765819,-73.975866&amp;zoom=14 &amp;x-success=sourceapp://?resume=true &amp;x-source=SourceApp 2.3.6 向应用添加导航1234567891011// 代码展示了如何使用 comgooglemaps-x-callback:// 架构来请求路线，然后在您的用户准备就绪后返回到您的应用。 该代码将执行以下操作NSURL *testURL = [NSURL URLWithString:@&quot;comgooglemaps-x-callback://&quot;];if ([[UIApplication sharedApplication] canOpenURL:testURL]) &#123; NSString *directionsRequest = @&quot;comgooglemaps-x-callback://&quot; + @&quot;?daddr=John+F.+Kennedy+International+Airport,+Van+Wyck+Expressway,+Jamaica,+New+York&quot; + @&quot;&amp;x-success=sourceapp://?resume=true&amp;x-source=AirApp&quot;; NSURL *directionsURL = [NSURL URLWithString:directionsRequest]; [[UIApplication sharedApplication] openURL:directionsURL];&#125; else &#123; NSLog(@&quot;Can&apos;t use comgooglemaps-x-callback:// on this device.&quot;);&#125; 该代码将执行以下操作： 验证 comgooglemaps-x-callback:// URL 架构是否可用。 启动 iOS 版 Google Maps 应用，并请求前往纽约市肯尼迪国际机场的路线。 将起始地址留空即可请求从用户的当前位置出发的路线。 将标记为“AirApp”的按钮添加到 iOS 版 Google Maps 应用中。 该按钮标签由 x-source 参数定义。 当用户点击返回按钮时，调用虚拟 URL 架构 sourceapp://,。 三.遇到的问题开发中难免遇到一些稀奇古怪的问题, 这里就着我遇到的问题分享一下; 需求:实现一个自定义的弹窗, 要求点击弹窗左边视图返回上一页, 点击右边视图跳转导航功能; 问题:在mapView:markerInfoWindow:中我自定义了一个气泡视图, 视图左右各一个按钮, 按钮的点击方法被屏蔽, 只响应了整个气泡视图的点击方法(mapView:didTapInfoWindowOfMarker:); 解决办法:在试了n个方法后, 终于让我找到了SMCalloutView, github上的一个自定义气泡的三方, 可以自由定义左右,中间, 背景视图, 非常棒👍, O(∩_∩)O哈哈~ 首先是基础操作:12345678#import &lt;SMCalloutView/SMCalloutView.h&gt;static const CGFloat CalloutYOffset = 10.0f;@interface ViewController ()@property (strong, nonatomic) SMCalloutView *calloutView;@property (strong, nonatomic) UIView *emptyCalloutView;@end 之后初始化SMCalloutView, 创建一个空View;1234567- (void)viewDidLoad&#123; self.calloutView = [[SMCalloutView alloc] init]; self.calloutView.contentView = [UIView new]; self.emptyCalloutView = [[UIView alloc] initWithFrame:CGRectZero];&#125; 其次是GMSMapViewDelegate里面的设置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (UIView *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker &#123; CLLocationCoordinate2D anchor = marker.position; CGPoint point = [mapView.projection pointForCoordinate:anchor]; self.calloutView.calloutOffset = CGPointMake(0, -CalloutYOffset); //SMCalloutView中contentView UIView *googleTipView = [UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 50); //左方按钮 UIButton *leftButton = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 100, 50)]; [googleTipView addSubview:bView]; [leftButton addTarget:self action:@selector(leftButtonClick:) forControlEvents:UIControlEventTouchUpInside]; //右方按钮 UIButton *rightButton = [[UIButton alloc] initWithFrame:CGRectMake(100, 0, 100, 50)]; [googleTipView addSubview:bView]; [rightButton addTarget:self action:@selector(rightButtonClick:) forControlEvents:UIControlEventTouchUpInside]; //取消默认背景 SMCalloutBackgroundView *calloutBgView = [[SMCalloutBackgroundView alloc] initWithFrame:CGRectZero]; self.calloutView.backgroundView = calloutBgView; self.calloutView.contentView = googleTipView; self.calloutView.hidden = NO; CGRect calloutRect = CGRectZero; calloutRect.origin = point; calloutRect.size = CGSizeZero; [self.calloutView presentCalloutFromRect:calloutRect inView:mapView constrainedToView:mapView animated:YES]; return self.emptyCalloutView;&#125;- (void)mapView:(GMSMapView *)pMapView didChangeCameraPosition:(GMSCameraPosition *)position &#123; if (pMapView.selectedMarker != nil &amp;&amp; !self.calloutView.hidden) &#123; CLLocationCoordinate2D anchor = [pMapView.selectedMarker position]; CGPoint arrowPt = self.calloutView.backgroundView.arrowPoint; CGPoint pt = [pMapView.projection pointForCoordinate:anchor]; pt.x -= arrowPt.x; pt.y -= arrowPt.y + CalloutYOffset; self.calloutView.frame = (CGRect) &#123;.origin = pt, .size = self.calloutView.frame.size &#125;; &#125; else &#123; self.calloutView.hidden = YES; &#125;&#125;- (void)mapView:(GMSMapView *)mapView didTapAtCoordinate:(CLLocationCoordinate2D)coordinate &#123; self.calloutView.hidden = YES;&#125;- (BOOL)mapView:(GMSMapView *)mapView didTapMarker:(GMSMarker *)marker &#123; mapView.selectedMarker = marker; return YES;&#125; 结果就可以在点击方法里面尽情的调用了:12345678//左边按钮点击方法- (void)leftButtonClick:(UIButton *)button&#123;&#125;//右边按钮点击方法- (void)rightButtonClick:(UIButton *)button&#123;&#125; 最后感谢这位网友的分享, 附上链接:stackoverflow网友的分享 关于Google地图开发:iOS Google地图SDK入门教程iOS－－谷歌地图相关功能的实现]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>objective-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic难点问题整理(持续更新)]]></title>
    <url>%2F2017%2F09%2F09%2Fionic-diffict-problems%2F</url>
    <content type="text"><![CDATA[1. iOS端长数字自动识别为电话，颜色变蓝h5:1&lt;p&gt;&#123;&#123;data.mobilePhone&#125;&#125;&lt;/p&gt; 效果图:解决办法:index.html的head中加入代码👇:1&lt;meta name="format-detection" content="telephone=no" /&gt; 处理后效果图: 2. ion-radio设置选中/不可用样式设置单选框选中样式:(仅以背景颜色为例)css:123.item-radio input:checked + .radio-content .item-content &#123; background: #5cbaf0;&#125; 设置单选框不可用的样式:(仅以背景颜色为例)css:123.item-radio input:disabled + .radio-content .item-content &#123; background: #5cbaf0;&#125; 附:ion-radio API]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我喜欢用SDAutoLayout]]></title>
    <url>%2F2017%2F09%2F02%2FiOS-SDAutoLayout%2F</url>
    <content type="text"><![CDATA[基本的适配方法就不做介绍了, 👇主要介绍一些个人认为的SDAutoLayout适配亮点; 亮点1—— UILabel 1.1 label设置最大宽度与行数 testLabel设置最大宽度与行数:123456789101112_testLabel.text = @&quot;近段时间，人民币出现快速升值，到底是因为人民币“自强了”，还是美元“弱爆了”？对比美元指数跌幅与人民币对美元升幅，不难发现，美元走弱依旧是推动人民币兑美元汇率升值的主要原因。&quot;;_testLabel.sd_layout.topSpaceToView(self.view, 50).leftSpaceToView(self.view, 20).autoHeightRatio(0);// 设置最大宽度[_testLabel setSingleLineAutoResizeWithMaxWidth:200];// 设置最大行数[_testLabel setMaxNumberOfLinesToShow:3]; 1.2 label富文本自适应 testLabel富文本自适应:123456789101112131415161718NSString *contentStr = @&quot;近段时间，人民币出现快速升值，到底是因为人民币“自强了”，还是美元“弱爆了”？对比美元指数跌幅与人民币对美元升幅，不难发现，美元走弱依旧是推动人民币兑美元汇率升值的主要原因。&quot;;NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];[paragraphStyle setLineSpacing:10];UIColor *color = [UIColor whiteColor];NSAttributedString *contentString = [[NSAttributedString alloc] initWithString:contentStr attributes:@&#123;NSForegroundColorAttributeName : color, NSParagraphStyleAttributeName: paragraphStyle&#125;];_testLabel.attributedText = contentString;_testLabel.sd_layout.leftSpaceToView(self.view, 20).rightSpaceToView(self.view, 20).topSpaceToView(self.view, 100).autoHeightRatio(0);// 只需执行这步代码, 即可适配富文本_testLabel.isAttributedContent = YES; 亮点2—— UIButton 2.1 button里的titleLabel和imageView可以分开适配 testButton代码:123456789101112131415161718192021_testButton.sd_layout.centerXEqualToView(self.view).centerYEqualToView(self.view).widthIs(200).heightIs(200);_testButton.imageView.sd_layout.topSpaceToView(_testButton, 20).centerXEqualToView(_testButton).widthIs(100).heightIs(100);_testButton.imageView.layer.cornerRadius = 50;_testButton.imageView.layer.masksToBounds = YES;_testButton.titleLabel.sd_layout.bottomSpaceToView(_testButton, 20).centerXEqualToView(_testButton).leftSpaceToView(_testButton, 20).rightSpaceToView(_testButton, 20).heightIs(40); 2.2 button根据文字内容自适应大小 testButton文字自适应:12345678[_testButton setTitle:@&quot;testButton文字自适应&quot; forState:UIControlStateNormal];_testButton.sd_layout.centerXEqualToView(self.view).topSpaceToView(self.view, 200);// 设置button根据文字size自适应[_testButton setupAutoSizeWithHorizontalPadding:5 buttonHeight:24]; 亮点3—— UIScrollView 3.1 scrollView设置类似于collectionView布局效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 添加scrollview- (void)setupScrollView&#123; UIScrollView *scroll = [UIScrollView new]; [self.view addSubview:scroll]; _testScrollView = scroll; // 设置scrollview与父view的边距 scroll.sd_layout.spaceToSuperView(UIEdgeInsetsZero); [self setupFlowItemContentView]; // 设置scrollview的contentsize自适应 [scroll setupAutoContentSizeWithBottomView:_flowItemContentView bottomMargin:10];&#125;// 添加flowItemContentView- (void)setupFlowItemContentView&#123; _flowItemContentView = [UIView new]; _flowItemContentView.backgroundColor = [[UIColor lightGrayColor] colorWithAlphaComponent:0.4]; [_testScrollView addSubview:_flowItemContentView]; _flowItemContentView.sd_layout .leftEqualToView(_testScrollView) .rightEqualToView(_testScrollView) .topEqualToView(_testScrollView); [self setupFlowItemViews];&#125;- (void)setupFlowItemViews&#123; NSMutableArray *temp = [NSMutableArray new]; for (int i = 0; i &lt; 35; i++) &#123; UIView *view = [UIView new]; view.backgroundColor = [self randomColor]; [_flowItemContentView addSubview:view]; view.sd_layout.autoHeightRatio(0.8); [temp addObject:view]; &#125; // 关键步骤：设置类似collectionView的展示效果 [_flowItemContentView setupAutoWidthFlowItems:[temp copy] withPerRowItemsCount:4 verticalMargin:20 horizontalMargin:10 verticalEdgeInset:0 horizontalEdgeInset:0];// [_flowItemContentView setupAutoMarginFlowItems:[temp copy] withPerRowItemsCount:10 itemWidth:60 verticalMargin:20 verticalEdgeInset:10 horizontalEdgeInset:0];&#125; 3.2 复杂页面scrollView自适应 亮点4—— UITableViewtableView的cell自适应, 自带方法解决;主要有三点需要注意:a. 在tableView的cellForRowAtIndexPath:方法中赋值;1cell.model = model; b. heightForRowAtIndexPath:里计算行高;1return [self.tableView cellHeightForIndexPath:indexPath model:model keyPath:@&quot;model&quot; cellClass:currentClass contentViewWidth:[self cellContentViewWith]]; c. cell中适配的时候设置底部边界;12// 当你不确定哪个view在自动布局之后会排布在cell最下方的时候可以调用次方法将所有可能在最下方的view都传过去[self setupAutoHeightWithBottomViewsArray:@[_titleLabel, _imageView] bottomMargin:margin]; 而且不光如此, 还加入了缓存高度的设置;12// 此步设置用于实现cell的frame缓存，可以让tableview滑动更加流畅 [cell useCellFrameCacheWithIndexPath:indexPath tableView:tableView]; 是不是比较贴心呢, 当然里面还有一些其他方法, 就不一一列举, 附上官方demo链接, 希望对大家有所帮助;SDAutoLayout]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS性能优化---tableView懒加载图片]]></title>
    <url>%2F2017%2F07%2F07%2FiOS-tableView-image%2F</url>
    <content type="text"><![CDATA[关于tableView的性能优化问题一直都是iOS开发者必备的一项优化技能, 可以好不夸张的说, app里面半数以上的页面都需要用到tableView; 对于它的优化网友也总结的非常详细, 鄙人就不详细解释了, 附个链接:关于tableview的优化 本文主要介绍一下如何在tableView中实现懒加载图片, 别怪我多嘴, 一些初学者对懒加载的印象可能是这样的:123456789101112@interface ViewController()@property (nonatomic,strong) NSMutableArray *lazyLoadArr;@end@implementation ViewController- (NSMutableArray *)lazyLoadArr&#123; if (!_lazyLoadArr) &#123; _lazyLoadArr = [NSMutableArray array]; &#125; return _lazyLoadArr;&#125;@end 实例中定义了一个懒加载的可变数组, 重写数组的getter方法, 在该方法中判断是否存在lazyLoadArr, 如果存在就返回, 不存在就初始化, 这样保证数组只加载了一次; 而这个只是懒加载中比较常见的一种用法;那么什么是懒加载呢? 懒加载也叫延迟加载, 或者通俗来讲就是用到时再去加载对象 也就是说用到这种思想的基本上都属于懒加载; 其实在tableView懒加载图片也是app中比较常见的功能; 它可以可以减轻服务器的压力, 节约流量, 提高页面的加载速度等等, 费这么大劲儿, 最终也是为了更好的用户体验;先附上实现效果图, 让大家感受一下: 这个例子节选自苹果的官方例子LazyTableImages实现图片懒加载;LazyTableImages下载 OK, 现在我们开始剖析一下代码;附上工程目录: 首先说一下细节部分, 其实也不是什么大问题, 留意一下:①工程里面的AppDelegate类被替换成LazyTableAppDelegate, 其实在函数入口main.m替换下类就行;②pch文件导入了Foundation, UIKit框架全局调用, 所以出现了以下情况: 一般对对象的基础操作都放在了Foundation.h, 为了方便, 通常也就直接引入; 数据请求为了减少数据延迟加载的卡顿感, demo里直接把数据请求写在了LazyTableAppDelegate文件中; 选一小段代码说一下:123456789101112131415__weak ParseOperation *weakParser = self.parser;self.parser.completionBlock = ^(void) &#123; [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; if (weakParser.appRecordList != nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; RootViewController *rootViewController = (RootViewController*)[(UINavigationController*)weakSelf.window.rootViewController topViewController]; rootViewController.entries = weakParser.appRecordList; [rootViewController.tableView reloadData]; &#125;); &#125; weakSelf.queue = nil;&#125;;[self.queue addOperation:self.parser]; block循环引用问题, 这个经常遇到, 就不多说了; 数据请求是在子线程里进行了, 然而要想对UI进行操作, 需要回到主线程, 刷新数据; 对于networkActivityIndicatorVisible, 这个是UIApplication的一个属性, 用于在状态栏上显示菊花转的图标，表明网络状态, 而我们平常都是用MB或者SVP来表示网络加载的, 有可能没见过, 说明一下; UI部分(tableView)看了示意图我们发现只有在tableView松开的时候才加载图片, 那这个是怎么实现的呢, 我从tableView的cellForRowAtIndexPath:代理方法中选了一段代码:123456789101112if (!appRecord.appIcon) &#123; if (self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO) &#123; [self startIconDownload:appRecord forIndexPath:indexPath]; &#125; cell.imageView.image = [UIImage imageNamed:@&quot;Placeholder.png&quot;]; &#125; else &#123; cell.imageView.image = appRecord.appIcon; &#125; 当没有下载好的图片, 即!appRecord.appIcon时, 判断是否停止拖拽(self.tableView.dragging == NO)或者加速度为0(self.tableView.decelerating == NO), 都满足的话就下载图片, 这样就实现了图示效果;但是光这样处理是不够的, 如果连续拖动, 不让tableView停止, 里面的图片是空的, 所以还要进行下面的操作:123456789101112- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; if (!decelerate) &#123; [self loadImagesForOnscreenRows]; &#125;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; [self loadImagesForOnscreenRows];&#125; 由于tableView继承了scrollView, 所以才在dragging和decelerating结束的时候加载图片, 最终实现了图示效果; 优化亮点一. 图片圆角优化一般在开发中我们是这样给图片切圆角的:12myImage.layer.cornerRadius = 50;myImage.layer.masksToBounds = YES; 其中masksToBounds(CALayer)表示视图的图层上的子图层,如果超出父图层的部分就截取掉；还有clipsToBounds(UIView)，是指视图上的子视图,如果超出父视图的部分就截取掉。在iOS9.0之前这样设置会触发离屏渲染，比较消耗性能。尤其是tableView中(处理了大量图片)，会明显的感到页面有轻微卡顿。那要怎么处理呢, 一般我们用Core Graphics绘制圆角, 附上工程里的代码:123456CGSize itemSize = CGSizeMake(kAppIconSize, kAppIconSize);UIGraphicsBeginImageContextWithOptions(itemSize, NO, 0.0f);CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);[image drawInRect:imageRect];self.appRecord.appIcon = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); 二. model的小技巧我们发现在工程中, 无论对于tableView来说, 还是下载图片来说, 都是对同一个对象进行操作, demo中把tableView数据里面的对象扩展了下面这两条属性:12@property (nonatomic, strong) UIImage *appIcon;@property (nonatomic, strong) NSString *imageURLString; 这样我们去下载图片的时候, 只需要传进去一个AppRecord类的对象, 返回来也是同一个对象:123 // 将下载完成的网络图片的data值传给这个对象UIImage *image = [[UIImage alloc] initWithData:data];self.appRecord.appIcon = image; 有人要问了只是简化了传入的数据嘛, 没什么特别的, 但是你细看tableView里面cellForRowAtIndexPath方法就会发现, 这样做既简化了逻辑判断, 又易于理解, 因为是同一个对象;12345678910111213AppRecord *appRecord = (self.entries)[indexPath.row]; if (!appRecord.appIcon) // 简便的判断条件 &#123; if (self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO) &#123; [self startIconDownload:appRecord forIndexPath:indexPath]; &#125; cell.imageView.image = [UIImage imageNamed:@&quot;Placeholder.png&quot;]; &#125; else &#123; cell.imageView.image = appRecord.appIcon; &#125; 这个思想真是不由得让老铁双击666啊, 非常棒👍; 好的, 这次就分享那么多, 以后还得研究更多更深的源码, 加油⛽️;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《AngularJs权威指南》学习笔记---指令]]></title>
    <url>%2F2017%2F07%2F03%2Fangularjs-bookNote%2F</url>
    <content type="text"><![CDATA[记得最开始学习ionic混合开发的时候, 朋友们都推荐我先学学angular.js, 然后再看ionic框架的东西; 现在想来也确实, ionic框架基本都是UI相关的知识, 并不难, 而页面里面涉及到angular.js的各种逻辑才是真正能让一个人成为大牛的知识; 选这本书就是因为朋友们都推荐这本, 而且讲的还不错, 最重要的是他们有资源, O(∩_∩)O哈哈~ 首先介绍一下本书中关于指令的知识结构: 一. 指令简介用过HTML的都知道, 往往在实现一些特殊功能的时候, 原有的HTML标签并不完全能满足设计要求, 这时候指令就派上用场了; 指令本质上就是扩展一些自定义的HTML元素以实现一些特定的功能; 二. 内置指令AngularJS事实上也是在原生JS的基础上进行一些扩展和优化, 自然就会包括一些自定义的内置指令; 除了form和a等一些重载了原生的HTML元素, 其他的内置指令通常以ng作为前缀; 这样做的目的也是对原生的一种优化, 比如常用的href指令, 无论里面的链接是可用还是, 不可用的, 当调用href的时候, 就会直接返回调用结果; 而ng-href指令则是当里面的表达式调用并且返回一个值的时候才开启, 否则会是一个禁用状态; 当然既然人家官方用ng这个前缀, 你就不要跟人家抢了, 换一个, 大家和谐一点儿; 有网友总结了一下AngularJS的内置指令, 一共有63个; 简单介绍一下form指令:123456789&lt;form&gt;First name:&lt;/br&gt;&lt;input type="text" name="firstname" value="huo"&gt;&lt;br&gt;Last name:&lt;/br&gt;&lt;input type="text" name="lastname" value="yu"&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; 效果图: 要注意一下几点: HTML原生的form表单是不能嵌套的, 但Angular封装后可以嵌套 Angular为form扩展了自动校验, 防止重复提交等功能 Angular对input元素的type进行了了扩展, 一共提供一下10中类型:text, number, url, email, radio, checkbox, hidden, button, submit, reset; Angular为表单内置了4种CSS样式ng-valid, ng-invalid, ng-pristine, ng-dirty; 内置校验器: require, minlength, maxlength 三. 指令详解1. 指令定义本书中对指令的定义是在特定DOM元素上运行的函数, 指令可以扩展这个元素的功能;在Angular中是通过directive()这个模块来定义指令的;而directive()可以接受两个参数: name指令的名字 factory_function(函数)这个函数定义了指令的行为1234567 angular.application('myApp', []) .directive('myDirective', function() &#123; // 一个指令定义对象 return &#123; // 通过设置项来定义指令, 在这里进行填写 &#125;;&#125;); 在HTML中调用就行:1&lt;div my-directive&gt;&lt;/div&gt; 2. 指令函数介绍2.1 restrict(字符串) 这些选项可以单独使用, 也可以混合使用; 2.2 优先级(数值型)由于考虑到性能问题, ngRepeat被设置成所有内置指令中优先级最高的; 当然如果两个元素的优先级一样, 会执行先声明的那个; 2.3 terminal(布尔型)它用来告诉AngularJs停止运行当前元素上比本指令优先级低的指令, 但当优先级相同的情况还是会运行;例如:ngView和ngIf, ngIf的优先级略高于ngView, 如果ngIf表达式为true, ngView就可以被正常执行; 但如果ngIf的表达式为false, ngView就不会被执行; 2.4 template(字符串或函数)template参数必须被设置成以下两种形式之一: 一段HTML文本 一个可以接受两个参数的的函数, 参数为tElement和tAttrs, 并返回一个代表模板的字符串; 2.5 templateUrl(字符串或函数)templateUrl参数可以是以下形式: 一个代表外部HTML文件的路径字符串 一个可以接受两个参数的的函数, 参数为tElement和tAttrs, 并返回一个代表模板的字符串; 2.6 replace(布尔型)replace是个可选参数, 默认为false; 当设置为true后123456.directive('someDirective', function() &#123; return &#123; replace: true template: '&lt;div&gt;looking for something&lt;div&gt;' &#125;; &#125;); 输出结果为:1&lt;div&gt;looking for something&lt;div&gt; 2.7 scope参数(布尔型或对象)scope参数有三种取值方式;2.7.1 false(默认值)直接使用父scope, 内部并没有一个新的scope，它和指令以外的代码共享同一个scope。①指令123456789app.directive('myDirective', function() &#123; return &#123; restrict: 'E', replace: true, templateUrl: '../templates/my_template.html', scope: false, // 默认值 controller: null &#125;&#125;); ②指令模板(my_template.html)12345&lt;div&gt; &lt;!--这里ng-model绑定的input，就是父scope的变量input--&gt; &lt;p&gt;自定义指令scope：&lt;input type="text" ng-model="input"&gt;&lt;/p&gt; &lt;p&gt;结果：&#123;&#123;input&#125;&#125;&lt;/p&gt;&lt;/div&gt; ③指令的使用(index.html)12345&lt;body ng-app="scopeTest" ng-controller="scopeTestStr"&gt; &lt;p&gt;父scope：&lt;input type="text" ng-model="input"&gt;&lt;/p&gt; &lt;!--自定义指令--&gt; &lt;my-directive&gt;&lt;/my-directive&gt;&lt;/body&gt; 效果如下: 2.7.2 true(继承父scope)当设置为true的时候, 会从父作用域继承并创建一个新的作用域对象;参照值为false的情况, 只是将值改为true; 效果如下: 2.7.3 { }创建一个新的”隔离”scope，但仍可与父scope通信;隔离的scope，通常用于创建可复用的指令，也就是它不用管父scope中的model。然而虽然说是“隔离”，但通常我们还是需要让这个子scope跟父scope中的变量进行绑定。绑定的策略有3种： ①@ 单项绑定1234567891011121314151617181920&lt;body ng-app="scopeTest"&gt; &lt;!--外部scope--&gt; &lt;p&gt;父scope：&lt;input type="text" ng-model="input"&gt;&lt;/p&gt; &lt;!--内部隔离scope--&gt; &lt;my-directive my-text="&#123;&#123;input&#125;&#125;"&gt;&lt;/my-directive&gt; &lt;script&gt; var app = angular.module('scopeTest', []); app.directive('myDirective', function () &#123; return &#123; restrict: 'E', replace: true, template: '&lt;p&gt;自定义指令scope：&lt;input type="text" ng-model="myText"&gt;&lt;/p&gt;', scope: &#123; myText: '@' &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 效果图: ②= 双向绑定12345678910111213141516171819202122&lt;body ng-app="scopeTest"&gt; &lt;!--外部scope--&gt; &lt;p&gt;父scope：&lt;input type="text" ng-model="input"&gt;&lt;/p&gt; &lt;!--内部隔离scope--&gt; &lt;!--注意这里，因为是双向绑定，所以这里不要“&#123;&#123;&#125;&#125;”这个符号--&gt; &lt;my-directive my-text="input"&gt;&lt;/my-directive&gt; &lt;script&gt; var app = angular.module('scopeTest', []); app.directive('myDirective', function () &#123; return &#123; restrict: 'E', replace: true, template: '&lt;p&gt;自定义指令scope：&lt;input type="text" ng-model="myText"&gt;&lt;/p&gt;', scope: &#123; myText: '=' // 这里改成了双向绑定 &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 效果图: ③&amp; 内部scope的函数返回值和外部scope绑定12345678910111213141516171819202122&lt;body ng-app="scopeTest"&gt; &lt;!--外部scope--&gt; &lt;p&gt;父scope：&lt;input type="text" ng-model="input"&gt;&lt;/p&gt; &lt;!--内部隔离scope--&gt; &lt;!--注意这里，函数名字也要用 连字符命名法--&gt; &lt;my-directive get-my-text="input"&gt;&lt;/my-directive&gt; &lt;script&gt; var app = angular.module('scopeTest', []); app.directive('myDirective', function () &#123; return &#123; restrict: 'E', replace: true, template: '&lt;p&gt;结果：&#123;&#123; getMyText() &#125;&#125;&lt;/p&gt;', scope: &#123; getMyText: '&amp;' // 这里改成了函数返回值的绑定 &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 效果图: 2.8 transclude(布尔型)默认为false; 只有当你希望创建一个可以包含任意内容的指令的时候才会为true; 代码如下所示:1234567app.directive('myDirective', function() &#123; return &#123; restrict: 'AE', transclude: true, template: "&lt;div&gt; hellow angular ! &lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;" &#125;&#125;); 2.9 controller(字符串或函数)指令内部的controller, 暴露一些public方法给内部指令使用;①字符串;1234567891011angular.module('myApp', []) .directive('myDirective', function() &#123; restrict: 'A', // 始终需要 controller: 'SomeController'&#125;)// 在应用中其他地方定义该控制器angular.module('myApp') .controller('SomeController', function($scope, $element, $attrs, $transclude) &#123; // 控制器逻辑&#125;); ②函数可以是指令内部通过匿名构造函数的方式来定义一个内联的控制器;12345678 angular.module('myApp',[]) .directive('myDirective', function() &#123; restrict: 'A', controller: function($scope, $element, $attrs, $transclude) &#123; // 控制器逻辑 &#125;&#125;); 现在你也可以知道, 控制器中还有其他一些特殊的服务可以注入到指令中, 这些服务有: $scope 指令对应的作用域 $element 指令对应的元素 $attrs 当前元素属性组成的对象 $transclude 嵌入链式函数会与对应的嵌入作用域进行预绑定 在控制器内部操作DOM和angular.js风格相悖的做法, 但通过链式函数就可以实现这个需求; 例如在compile参数中使用transcludeFn是推荐的做法; 本文提供了一个添加超链接的例子:12345678910111213141516 angular.module('myApp') .directive('link', function() &#123; return &#123; restrict: 'EA', transclude: true, controller: function($scope, $element, $transclude, $log) &#123; $transclude(function(clone) &#123; var a = angular.element('&lt;a&gt;'); a.attr('href', clone.text()); a.text(clone.text()); 8 $log.info("Created new a tag in link directive"); $element.append(a); &#125;); &#125; &#125;;&#125;); link函数可以与控制器指令的控制器互换; 控制器用来提供指令间的复用行为, 但链接函数只能在当前内部指令中定义行为且无法在指令间复用; link函数可以将指令互相隔离, 而controller则定义可复用的行为; 下面附一张link函数与compile函数的比较图: 2.10 require(字符串或数组)字符串或数组的值会是当前指令作用域中使用的指令名称, 即用来调用暴露的内部方法; 对于指令的学习, 书中提供了内部原理, 当然光这些还是远远不够, 附上一个第三方指令库, 看看源码, 体验一下别人是怎么写的;AngularUI]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>angular.js</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lottie动画教程]]></title>
    <url>%2F2017%2F07%2F03%2Flottie-simple-tutorial%2F</url>
    <content type="text"><![CDATA[为了提升用户体验, 在界面中加入一个设计良好的界面动画成为app设计的潮流. 之前听有人说过专业的界面动画是要有设计师、工程师、程序员、平面动画师等组成, 想想这是一个多大的任务量啊. 而且里面的各种逻辑处理, 复杂一些的动画, 一般人几乎是望其项背; 但有了Lottie之后, 就大大降低了开发者的难度. 我们可以直接把Lottie的动画文件导入, 设置一下参数, 就可以使用这个动画了. 为了满足大家的好奇心, 先附几个简单的实例: 一. 初识Lottie通过AE上的Bodymovin插件将AE中制作好的动画导出成一个json文件，Lottie实现了iOS/macOS/Android/React Native三个平台对该json文件的解析和渲染。 所有这些动画都是在After Effects中创建的，使用Bodymovin导出，并且无需额外的工程师工作即可完成原生渲染。 Bodymovin是一个又Hernan Torrisi创建的After Effects插件，导出文件格式为json和包括一个javascript网络播放器。而它最大的优点是提供了一套完整的跨平台动画实现工作流; 从代码上看，iOS端是基于layer，而最终都是对canvas的操作，中间除去解析json外，基本无耗费性能的行为。 当然也不可能都那么完美, 毕竟开源不久, 它仍然存在以下问题: Bodymovin插件待完善，仍然有部分AE效果无法成功导出； Lottie对json文件的支持待完善，目前有部分能成功导出成json文件的效果在移动端上无法很好的展现； 目前不支持文字，所有文字必须转成矢量图才能正常展现动画； 动画无法被编辑，即移动端无法更改远端下载到本地的动画； 文档更新不及时等;注:iOS需要iOS8及以上, 安卓需要API14及以上; 二. 如何用Bodymovin插件制作动画iTerryWang在他的简书博客里详细介绍了如何使用Bodymovin插件制作动画, 我就不多说了, 也同时感谢一下iTerryWang的分享;Lottie简介 &amp; iOS集成使用 三. 如何使用Lottie1. 下载Lottie动画文件除了用Bodymovin插件创建动画外, 我们还可以在Lottie Files下载; Lottie Files是一个拥有高质量Lottie文件格式动画的网站。在这个网站，不仅设计师可以在上面陈列他们的动画而且还提供免费下载. 这步结束后, 我们就准备好了动画所需的JSON文件; 2. 新建工程新建一个工程, 命名为LottieTest; 3. 导入Lottie动画库用CocoaPods安装Lottie动画库:在终端进行如下操作:①进入文件目录(文件目录要用自己的工程目录);1cd /Users/apple/Desktop/LottieTest ②创建podfile1pod init ③打开文件编辑123target 'LottieTest' do pod 'lottie-ios'end ④导入Lottie项目1pod install 4. 添加Lottie动画的JSON文件之前已经准备好这个文件了, 导入工程就行; 5. 创建动画OC版:123456789101112131415161718192021#import &quot;ViewController.h&quot;#import &lt;Lottie/Lottie.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; LOTAnimationView *lottieTest = [LOTAnimationView animationNamed:@&quot;servishero_loading&quot;]; lottieTest.contentMode = LOTViewContentModeScaleAspectFill; lottieTest.frame = self.view.bounds; lottieTest.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable; [self.view addSubview:lottieTest]; [lottieTest play];&#125;@end swift版:1234567891011121314151617181920212223242526272829import UIKitimport Lottieclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() if let animationView = LOTAnimationView(name: "servishero_loading") &#123;// if let animationView = LOTAnimationView(contentsOf: URL(string: "https://github.com/airbnb/lottie-ios/raw/master/Example/Assets/LottieLogo1.json")!) &#123; animationView.frame = self.view.bounds animationView.center = self.view.center animationView.loopAnimation = true animationView.contentMode = .scaleAspectFill animationView.animationSpeed = 0.5 // Applying UIView animation let minimizeTransform = CGAffineTransform(scaleX: 0.1, y: 0.1) animationView.transform = minimizeTransform UIView.animate(withDuration: 3.0, delay: 0.0, options: [.repeat, .autoreverse], animations: &#123; animationView.transform = CGAffineTransform.identity &#125;, completion: nil) view.addSubview(animationView) animationView.play() &#125; &#125;&#125; 至于android, reactNative参照下方github地址:androidreactNative 扩展:Airbnb 动画库Lottie]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IPV6审核被拒的完整分析]]></title>
    <url>%2F2017%2F06%2F30%2FappStore-ipv6%2F</url>
    <content type="text"><![CDATA[自从去年6月1号Apple明文规定所有开发者提交新版本都必须支持IPV6-Only的网络，估计很多iOS开发者都遇到由于IPV6网络不支持造成的审核被拒的情况, 我被坑的不轻啊, 下面就来分析一下IPV6问题如何解决。 首先附一个审核被拒的原文: Guideline 2.1 - Performance - App Completeness We discovered one or more bugs in your app when reviewed on iPad running iOS 10.3.2 on Wi-Fi connected to an IPv6 network. Specifically, the app launched to a blank page. Please see attached screenshots for details. Next Steps To resolve this issue, please run your app on a device while connected to an IPv6 network (all apps must support IPv6) to identify any issues, then revise and resubmit your app for review. If we misunderstood the intended behavior of your app, please reply to this message in Resolution Center to provide information on how these features were intended to work. For new apps, uninstall all previous versions of your app from a device, then install and follow the steps to reproduce the issue. For updates, install the new version as an update to the previous version, then follow the steps to reproduce the issue. 大意是在iPad上运行iOS 10.3.2 wi - fi连接到IPv6网络, 应用程序启动是一个空白页。请在设备上运行您的应用程序,连接到IPv6网络, 然后修改并重新提交你的应用程序进行审查。 一. 简单介绍一下IPV6以及如何搭建检测环境首先IPV6，是对IPV4地址空间的扩充。目前当我们用iOS设备连接上Wifi、4G、3G等网络时，设备被分配的地址均是IPV4地址，但是随着运营商和企业逐渐部署IPV6 DNS64/NAT64网络之后，设备被分配的地址会变成IPV6的地址，而这些网络就是所谓的IPV6-Only网络，并且仍然可以通过此网络去获取IPV4地址提供的内容。简单来说就是IPV4不够用了, 要换IPV6, 这从苹果一向的以用户体验为主出发, 其实也是为了让用户能用着舒服;测试是否支持IPV6网上已有更多详细的方法, 照着搭建就行, 下方附搭建环境的方法: 苹果官方文档的搭建方法 苹果app上架因IPv6不支持而拒绝，本地IPV6测试方法 二. 解决办法总的来说有三个方面的问题: 服务器不支持IPV6 项目中导入的第三方SDK不支持IPV6 项目中涉及到的网络请求不支持IPV6 除了这些, 还有些其他因素, 比如苹果正在审核, 而你们的后台在部署接口, 这种才是真的坑爹😤啊, 不多说, 感觉眼泪止不住往下流了; 1. 服务器①检测服务器是否支持IPV6终端输入以下代码:(参照网上方法) dig +nocmd + nostats 你的域名 AAAA 这是看看你们的服务器在IPV6下是否有回应。 有错误的话, 对照下面的表: 改变DNS的配置，直到稳定返回 NOERROR 为止。 ②更改服务器配置阿里云 Ubuntu 支持 IPv6 的完整步骤 2. 第三方SDK这些问题一般会出现在那些维护的APP里面, 由于是初次开发APP的人所处的时间相对较远, 所以项目里所用的SDK会有一些功能缺失; 下面介绍几个第三方SDK的问题;①Reachability苹果都发话, 这个当然要改了;新的sdk包将这个方法干掉了：reachabilityForLocalWiFi，只要自己的代码中干掉就行了，没什么影响。 原因如下介绍：12345#pragma mark reachabilityForLocalWiFi//reachabilityForLocalWiFi has been removed from the sample. See ReadMe.md for more information.//+ (instancetype)reachabilityForLocalWiFi; ②JPush极光推送(v2.1.7开始支持)这个是我们项目里遇到的问题, SDK版本低了, 不支持IPV6; 从图中可以看出, 2.1.7版本才开始支持IPV6, 而我们版本是2.1.0; 唉😔, 乖乖升级咯;附:极光文档地址 ③微博SDK(v3.1.4开始支持) 而且从官方文档上发现, 更新SDK, 实际上是更新Reachability库; 附:微博SDK文档地址 ④友盟(v5.2.1开始支持) 附:友盟文档地址 ⑤微信(v1.5开始支持) 有简友说微信的sdk包是支持ipv6的，但是微信本身并不支持ipv6，所以说，即便你替换了最新的sdk包，在ipv6网络下还是不能用微信分享，因为你的app应用在ipv6网络环境下调不起微信，也就分享不了了，这个问题微信应该意识到了，估计后边的版本应该也是支持ipv6, 这个大家可以注意下;附:微信文档地址 ⑥QQ(未说明) 从变更历史也看不出从哪个版本开始支持的, 估计是觉得这点玩意儿不值得说吧. 大佬们的世界真是看不懂, 大家就按时间来估计吧;附:QQ文档地址 ⑦支付宝(未说明) 看下载的demo里面, 版本更新历史对具体哪个版本更新的未说明, 万一是最近被苹果打压的才更新的, 也不一定, 反正最新版本肯定是有了, 而且还多了些其他功能;附:支付宝文档地址 ⑧百度地图(v3.0.0开始支持) 附:百度地图文档地址 ⑨环信(v3.1.3开始支持) 附:环信文档地址 ⑩科大讯飞语音(v1.133开始支持) 附:科大讯飞语音文档地址 当然还有很多其他的SDK, 这里就不一一列举了, 根据项目里用了哪些, 看下官方文档SDK版本历史比对一下就行; 3. 网络请求其实对于ipv6_Only的处理，从两大方面进行自己审核：自身网络请求和三方涉及网络请求, 毕竟是由于网络问题;关于AFNetworking是否支持IPV6, 下面是一网友的说法: 而版本支持是在3.0以后; 当然, 听说网友还遇到了其他的问题:(这个我没遇到, 不过还是在这里记一下😆)内网的访问下是不可能连接到自己的服务器，后面测试一下公网阿里云的服务器，能够正常连接，这个可能是DNS64在搜索ipv6的过程中，并没有搜索内网的网络，导致内网连接失败; 如果这些还是没能解决你的问题, 可以看看下面这篇文章:http://www.jianshu.com/p/a6bab07c4062 最后感谢参考文章作者的分享, 希望攻城狮们早日解决bug, 继续撸代码, O(∩_∩)O哈哈~ 本文参考文章:iOS 被拒6次的ipv6Ipv6_Only 简单的理解（已验证，项目已经上线）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>appStore</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络请求错误整理]]></title>
    <url>%2F2017%2F06%2F28%2FiOS-http-error-code%2F</url>
    <content type="text"><![CDATA[在iOS开发中经常会遇到网络请求的错误, 一方面可能会是自己网络请求的方式, 参数, 请求头等造成的; 另一方面可能就是后台写的接口出了问题; 所以看懂报错原因就显得尤为重要. 一. iOS错误状态码经常遇到的错误是400~500, 下面主要整理下它们各自的报错原因: HTTP 错误 400400 请求出错由于语法格式有误，服务器无法理解此请求。不作修改，客户程序就无法重复此请求。 HTTP 错误 401401.1 未授权：登录失败此错误表明传输给服务器的证书与登录服务器所需的证书不匹配。请与 Web 服务器的管理员联系，以确认您是否具有访问所请求资源的权限。401.2 未授权：服务器的配置导致登录失败此错误表明传输给服务器的证书与登录服务器所需的证书不匹配。此错误通常由未发送正确的 WWW 验证表头字段所致。请与 Web 服务器的管理员联系，以确认您是否具有访问所请求资源的权限。401.3 未授权：由于资源中的 ACL 而未授权此错误表明客户所传输的证书没有对服务器中特定资源的访问权限。此资源可能是客户机中的地址行所列出的网页或文件，也可能是处理客户机中的地址行所列出的文件所需服务器上的其他文件。请记录试图访问的完整地址，并与 Web 服务器的管理员联系以确认您是否具有访问所请求资源的权限。401.4 未授权：授权服务被筛选程序拒绝此错误表明 Web 服务器已经安装了筛选程序，用以验证连接到服务器的用户。此筛选程序拒绝连接到此服务器的真品证书的访问。请记录试图访问的完整地址，并与 Web 服务器的管理员联系以确认您是否具有访问所请求资源的权限。401.5 未授权：ISAPI/CGI 应用程序的授权失败此错误表明试图使用的 Web服务器中的地址已经安装了 ISAPI 或 CGI程序，在继续之前用以验证用户的证书。此程序拒绝用来连接到服务器的真品证书的访问。请记录试图访问的完整地址，并与 Web服务器的管理员联系以确认您是否具有访问所请求资源的权限 HTTP 错误 403403.1 禁止：禁止执行访问如果从并不允许执行程序的目录中执行 CGI、ISAPI或其他执行程序就可能引起此错误。如果问题依然存在，请与 Web 服务器的管理员联系。403.2 禁止：禁止读取访问如果没有可用的默认网页或未启用此目录的目录浏览，或者试图显示驻留在只标记为执行或脚本权限的目录中的HTML 页时就会导致此错误。如果问题依然存在，请与 Web 服务器的管理员联系。403.3 禁止：禁止写访问如果试图上载或修改不允许写访问的目录中的文件，就会导致此问题。如果问题依然存在，请与 Web服务器的管理员联系。403.4 禁止：需要 SSL此错误表明试图访问的网页受安全套接字层（SSL）的保护。要查看，必须在试图访问的地址前输入https:// 以启用 SSL。如果问题依然存在，请与 Web服务器的管理员联系。403.5 禁止：需要 SSL 128此错误消息表明您试图访问的资源受 128位的安全套接字层（SSL）保护。要查看此资源，需要有支持此SSL 层的浏览器。请确认浏览器是否支持 128 位 SSL安全性。如果支持，就与 Web服务器的管理员联系，并报告问题。403.6 禁止：拒绝 IP 地址如果服务器含有不允许访问此站点的 IP地址列表，并且您正使用的 IP地址在此列表中，就会导致此问题。如果问题依然存在，请与 Web服务器的管理员联系。403.7 禁止：需要用户证书当试图访问的资源要求浏览器具有服务器可识别的用户安全套接字层（SSL）证书时就会导致此问题。可用来验证您是否为此资源的合法用户。请与 Web服务器的管理员联系以获取有效的用户证书。403.8 禁止：禁止站点访问如果 Web服务器不为请求提供服务，或您没有连接到此站点的权限时，就会导致此问题。请与 Web 服务器的管理员联系。403.9 禁止访问：所连接的用户太多如果 Web太忙并且由于流量过大而无法处理您的请求时就会导致此问题。请稍后再次连接。如果问题依然存在，请与 Web 服务器的管理员联系。403.10 禁止访问：配置无效此时 Web 服务器的配置存在问题。如果问题依然存在，请与 Web服务器的管理员联系。403.11 禁止访问：密码已更改在身份验证的过程中如果用户输入错误的密码，就会导致此错误。请刷新网页并重试。如果问题依然存在，请与 Web服务器的管理员联系。403.12 禁止访问：映射程序拒绝访问拒绝用户证书试图访问此 Web 站点。请与站点管理员联系以建立用户证书权限。如果必要，也可以更改用户证书并重试。 HTTP 错误 404404 找不到Web 服务器找不到您所请求的文件或脚本。请检查URL 以确保路径正确。如果问题依然存在，请与服务器的管理员联系。 HTTP 错误 405405 不允许此方法对于请求所标识的资源，不允许使用请求行中所指定的方法。请确保为所请求的资源设置了正确的 MIME 类型。如果问题依然存在，请与服务器的管理员联系。 HTTP 错误 406406 不可接受根据此请求中所发送的“接受”标题，此请求所标识的资源只能生成内容特征为“不可接受”的响应实体。如果问题依然存在，请与服务器的管理员联系。 HTTP 错误 407407 需要代理身份验证 在可为此请求提供服务之前，您必须验证此代理服务器。请登录到代理服务器，然后重试。如果问题依然存在，请与 Web 服务器的管理员联系。 HTTP 错误 412412 前提条件失败在服务器上测试前提条件时，部分请求标题字段中所给定的前提条件估计为FALSE。客户机将前提条件放置在当前资源 metainformation（标题字段数据）中，以防止所请求的方法被误用到其他资源。如果问题依然存在，请与 Web 服务器的管理员联系。 HTTP 错误 414414 Request-URI 太长 Request-URL太长，服务器拒绝服务此请求。仅在下列条件下才有可能发生此条件：客户机错误地将 POST 请求转换为具有较长的查询信息的 GET 请求。客户机遇到了重定向问题（例如，指向自身的后缀的重定向前缀）。服务器正遭受试图利用某些服务器（将固定长度的缓冲区用于读取或执行 Request-URI）中的安全性漏洞的客户干扰。如果问题依然存在，请与 Web 服务器的管理员联系。 HTTP 错误 500500 服务器的内部错误Web 服务器不能执行此请求。请稍后重试此请求。如果问题依然存在，请与 Web服务器的管理员联系。 HTTP 错误 501501 未实现Web 服务器不支持实现此请求所需的功能。请检查URL 中的错误，如果问题依然存在，请与 Web服务器的管理员联系。 HTTP 错误 502502 网关出错当用作网关或代理时，服务器将从试图实现此请求时所访问的upstream 服务器中接收无效的响应。如果问题依然存在，请与 Web服务器的管理员联系。 附:iOS网络请求的错误状态码维基百科 List of HTTP status codes 二. 特殊的错误处理 证书无效问题:NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9843) 当前服务器的证书无效, 网上也有很多其他的处理方式, 我选择的是下方这种, 附上代码:123456 @implementation NSURLRequest (NSURLRequestWithIgnoreSSL) + (BOOL)allowsAnyHTTPSCertificateForHost:(NSString *)host&#123; return YES; &#125;@end 把这个段代码 写到NSURLRequest分类中, 作用是 绕过SSL证书验证, 直接访问; 当然这样的做法不安全, 一般都不会这样做, 只是为了测试接口是否可用, 最好还是服务器添加证书;附:https信任证书的三种方式 希望看到此文的朋友们能够积极补充, 共同维护这篇文章, 多谢(^__^) 嘻嘻……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传苹果商店时一个不太平常的error]]></title>
    <url>%2F2017%2F06%2F23%2FappStore-upload-error%2F</url>
    <content type="text"><![CDATA[This action could not be completed. Try again. (-22421) 报错如图所示: 以前一直以为像这种错误只可能是网络问题, 最近升级了xcode, 出现这个问题, 解决两天才弄出来. 想来也最怕这种定位不到的问题, 网上众说纷纭, 最后在苹果的官方论坛里找到这个解决办法, 下面几十个点赞, 看来出问题的不止我一个, 也谢谢他们的分享, 哈哈;解决办法如下, 在终端按照步骤依次输入code:step1: cd ~ step2: mv .itmstransporter/ .old_itmstransporter/ step3: “/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter” 之后再次提交应该可以了, 希望能帮助到大家;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>appStore</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova插件用法详述(内含demo)]]></title>
    <url>%2F2017%2F06%2F23%2Fplugin-method-of-use%2F</url>
    <content type="text"><![CDATA[一. 导入插件用法(以cordova-plugin-appversion为例)1.导入方法:添加插件; cordova plugin add cordova-plugin-appversion 2.文件概述:导入的文件, 系统已自动配置好了一切需要配置的文件, 所以直接调用就OK了;js:12345document.addEventListener("deviceready", onDeviceReady, false); function onDeviceReady()&#123; // 设置App的版本号 $scope.version = AppVersion.version;&#125;; h5:123&lt;p&gt; 当前myFirstProject的版本为&#123;&#123;version&#125;&#125;&lt;/p&gt; 效果图:(包含了该插件的其他方法, 具体参见demo) 注意: 一般的插件，可以直接调用; 但是这种涉及到硬件或者系统的插件，就需要加上这个监听事件;1234// 监听事件document.addEventListener("deviceready", onDeviceReady, false); function onDeviceReady()&#123;&#125;; 附:cordova-plugin-appversion插件官方解释Cordova - 常用的插件与终端插件命令汇总 二.自定义插件用法1.创建自定义插件插件目录如下: |MyMath—-|src———|android————–MyMath.java———|ios————–MyMath.m—-|www———|MyMath.js—-plugin.xml 注意: 创建插件可以自己按照插件目录创建, 这样plugin.xml文件中太繁琐; 本文推荐用plugman创建插件, 既方便又不容易出错;附:使用plugman 创建一个自己的cordova插件 2.导入自定义插件按照链接创建好插件后, 就开始导入插件了; 这里我被坑的不浅啊, 看网上把插件放在plugins文件下, 然后update platforms; 可是完全不起作用, 还一顿报错; 原来此处就一句代码解决了;下方为终端输入: cordova plugin add /Users/apple/Desktop/test1 该方法添加插件后, 相应的config.xml, cordova_plugins.js, plugins会自动配置, 无需像手动导入的那么繁琐, 还容易出错; 3.使用说明demo给plugman创建的插件重新写入了方法, 具体实现看demo, 下方附上效果图; 点击下载demo]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自制cordova逆地理编码插件(OC)]]></title>
    <url>%2F2017%2F06%2F23%2Fcordova-plugin-geolocation%2F</url>
    <content type="text"><![CDATA[本文主要介绍iOS的逆地理定位插件, 用过官方的cordova-plugin-geolocation插件的都清楚, 该插件虽然得到了经纬度, 但是没法转换成我们想要位置信息, 于是就需要一个插件将经纬度转化为位置信息, 即逆地理编码;1.插件介绍该插件是用OC做的一个经纬度转换为位置的插件; OC内部通过CLGeocoder的方法实现逆地理编码;由于需要调用系统硬件, 所以该插件直到deviceready事件发生后才可用;1234document.addEventListener("deviceready", onDeviceReady, false); function onDeviceReady() &#123; console.log("deviceready");&#125; 2.自定义插件的添加下载好插件后, 直接添加本地目录即可;(插件最下方附上链接地址) cordova plugin add /Users/apple/Desktop/cordova-plugin-reverseGeocoding 3.用法实例1234567891011document.addEventListener("deviceready", onDeviceReady, false); function onDeviceReady() &#123; function success(message)&#123; alert("定位成功:" + message); &#125;; function error(message)&#123; alert("定位失败:" + message); &#125;; cordova.plugins.reverseGeocoding.address([24.840882, 102.843752], success, error);&#125; 4.使用说明返回的message是一个对象, 对象的结构如下:12345678910111213// &#123;// City = &quot;昆明市&quot;;// Country = &quot;中国&quot;;// CountryCode = CN;// FormattedAddressLines = (// &quot;中国云南省昆明市呈贡区吴家营街道仕林街&quot;// );// Name = &quot;仕林街&quot;;// State = &quot;云南省&quot;;// Street = &quot;仕林街&quot;;// SubLocality = &quot;呈贡区&quot;;// Thoroughfare = &quot;仕林街&quot;;// &#125; 5.要点介绍由于系统默认的语言是英文, 有些工程返回的数据信息是英文;之前试过更改NSUserDefaults里面的AppleLanguages, 去改变系统语言, 但是估计系统做了缓存处理, 所以程序重启后才生效. 最后用了一种简便的方法来实现切换语言, 如下图所示;(1)首先打开工程的edit scheme;(2)在run-options-application language中选择中文简体; (3)如果(2)中可以选择中文简体则不用执行这步;有的工程里面没有其他语言;则可在Localizations中添加;注:如果(3)还不可以选择中文的话, 可以新建一个OC工程(不是ionic工程哦, 用Xcode打开一个工程, 然后command+shift+n新建一个), 执行(3)中添加中文简体, 然后将最外面的zh-Hans.lproj文件夹copy到你的工程里面最外面的文件夹, 之后问题解决;值得注意的是, 执行了(3)后的添加localizations, 还得执行(2)中的切换系统语言; 附:插件下载地址]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>objective-c</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic优秀资源整理]]></title>
    <url>%2F2017%2F06%2F23%2Fionic-article%2F</url>
    <content type="text"><![CDATA[网上关于ionic的资源比较少, 好多刚入门的开发者找不到入门指导资源, 下面就推荐一些个人觉得比较好的资源; 一. 入门级指导官方文档, 这个当然必不可少https://ionicframework.com/docs/ 中文版的ionic文档，给英文不好的朋友 http://www.ionic.wang/js_doc-index.html ionic菜鸟教程, 里面有许多基础知识http://www.runoob.com/ionic/ionic-install.htmlionic2文档整理, 里面包含了所有控件的用法整理,很实用http://rainey.space/2016/04/06/Ionic2_Chinese_Document/ 小虎Oni的博客, 里面算是一些进阶的内容(包括按需加载controller, 一些性能优化等等)http://blog.csdn.net/onil_chen/article/category/6113346/2 二.解决一些问题cnodejs社区ionic，可以学习一下https://cnodejs.org/topic/545aee5a3e1f39344c5b3b3e 皓眸IT的博客，有许多ionic的知识，挺有价值的http://haomou.Net/2014/10/06/2014_ionic_learn/ ionic国内社区，可以互相学习下http://ionichina.com/ 三. 插件学习cordova插件用法详述(内含demo), 这个是我之前写的, 入门级的demo, 可以看看简单插件怎么写, OC与js的交互是怎样的http://www.jianshu.com/p/138568e87e7e cordova插件学习，对用ionic做开发会有帮助的http://rensanning.iteye.com/blog/2163892 四. 一些demo合集一些ionic的简单例子，从这些简单代码可以学到很多知识和理念 http://codepen.io/ionic/public-list/ Ionic系列——CodePen上的优秀Ionic_Demohttps://my.oschina.net/u/1416844/blog/514361?fromerr=bbFC5JIl ionic扩展插件, 包括:时间选择; 日期选择; 省市县三级联动等;http://www.cnblogs.com/luckyuns/p/6168715.html 五.爬坑指南(一些问题的解决办法)1.新建的工程一般写在外面的www文件中, build后会自动同步到staging文件夹下的www文件中;添加插件会自动build; 2.cordova没有跨域问题开发的时候遇到这个问题, 试了网上许多跨域的方法都没用;解决方案:(config.xml中修改)如果是浏览器，启动浏览器时带上参数 –disable-web-security “C:\Program Files (x86)\Google\Chrome\Application\chrome.exe” –user-data-dir=”” –disable-web-security 附:Ionic常见问题及解决方案http://blog.csdn.net/molong421/article/details/51587853]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>resources</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS处理单双击手势冲突问题]]></title>
    <url>%2F2017%2F06%2F22%2Fios-article%2F</url>
    <content type="text"><![CDATA[这个是之前开发中遇到的一个问题. 当一个视图同时响应单双击手势, 而实际上需要它只响应一个手势就行; 这种情况当手势同时加在一个视图上或者两个视图的关系为父子级时出现, 下面就来介绍一下处理的方法;这里展示一个demo:如图所示, 在storyboard中拖入两个view, 分别为bigView和smallView, smallView为bigView的子视图; 接下来给这两个视图拖入属性后, 给smallView加上单击事件, bigView加上双击事件;代码如下:1234567891011121314151617181920212223242526272829303132333435#import &quot;ViewController.h&quot;@interface ViewController ()@property (weak, nonatomic) IBOutlet UIView *bigView;@property (weak, nonatomic) IBOutlet UIView *smallView;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; UITapGestureRecognizer *singleTapGestureRecognizer = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(singleTap:)]; [singleTapGestureRecognizer setNumberOfTapsRequired:1]; [_smallView addGestureRecognizer:singleTapGestureRecognizer]; UITapGestureRecognizer *doubleTapGestureRecognizer = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(doubleTap:)]; [doubleTapGestureRecognizer setNumberOfTapsRequired:2]; [_bigView addGestureRecognizer:doubleTapGestureRecognizer];&#125;- (void)singleTap:(UIGestureRecognizer*)gestureRecognizer&#123; NSLog(@&quot;-----singleTap-----&quot;); [_smallView setBackgroundColor:[UIColor yellowColor]];&#125;- (void)doubleTap:(UIGestureRecognizer*)gestureRecognizer&#123; NSLog(@&quot;-----doubleTap-----&quot;); [_bigView setBackgroundColor:[UIColor redColor]];&#125; 接下来如果双击smallView, 你会发现视图变成下面这样: 本来双击只加载在smallView的父视图bigView上, 结果smallView也响应了, 这就尴尬了😓了;处理方式其实挺简单, 只不过最开始找了好久;下面贴出代码:(在viewDidLoad方法末尾添加)12//这行很关键，意思是只有当没有检测到doubleTapGestureRecognizer或者检测doubleTapGestureRecognizer失败，singleTapGestureRecognizer才有效 [singleTapGestureRecognizer requireGestureRecognizerToFail:doubleTapGestureRecognizer]; 好了, 完美解决(^__^) 嘻嘻……]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>objective-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js处理手势冲突之冒泡用法]]></title>
    <url>%2F2017%2F06%2F22%2Fjs-article%2F</url>
    <content type="text"><![CDATA[​ 嵌套的div元素，如果父级和子元素都绑定了一些事件，那么在点击最内层子元素时可能会触发父级元素的事件，下面介绍一下js阻止默认事件与js阻止事件冒泡示例. 一.event.preventDefault()​ 阻止元素的默认事件。如:a元素的点击跳转的默认事件 ，button，radio等表单元素的默认事件 ，div 元素没有默认事件;例: 下方为html代码:1&lt;a link="https://www.baidu.com"&gt;百度&lt;/a&gt; ​ 具体处理方式如下:1234567&lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $("a").click(function(event)&#123;​ event.preventDefault();​ &#125;);&#125;);&lt;/script&gt; 参考链接:jQuery 事件 - preventDefault() 方法 二.event.stopPropagation()​ 该方法将停止事件的传播，阻止它被分派到其他 Document 节点。在事件传播的任何阶段都可以调用它。注意，虽然该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。例:​ 下方为html代码:1234 &lt;div click="outsideDivAction()" style="background:blue;"&gt;​ &lt;div click="insideDivAction()" style="background:red;"&gt;​ &lt;/div&gt;&lt;/div&gt; ​ js中代码如下:123456 $scope.outsideDivAction = function()&#123;​ console.log("外面div方法执行");&#125;; $scope.insideDivAction = function()&#123;​ console.log("里面div方法执行");&#125;; ​ 执行上方代码发现, 点击里面的div, 外面的方法也会执行; 往往在实际工程中, 需要屏蔽外面的方法, 解决代码如下:1234 $scope.insideDivAction = function($event)&#123;​ $event.stopPropagation();​ console.log("里面div方法执行");&#125;; ​ 本以为这样就可以了, 但是后来才发现$event其实也算一个参数, 所以得在html中传递一下;​ html中添加参数如下:1&lt;div click="insideDivAction($event)" style="background:red;"&gt;&lt;/div&gt; 参考链接:stopPropagation() 方法希望这篇文章能帮到大家, 谢谢;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>